#!/usr/bin/env bash
while read -r INPUT
do

	# timestamp, source and level are defaults
	# there are potentially three timestamps: from filebeat reading the log, from the container processing the output and the output itself

	# internal message must implement following properties in this order: origin, @timestamp, source, level,
	level="$1" # INFO (stdout) or ERROR (stderr)

  # when implementing custom handler: if INPUT starts with '{ "origin": ' then the message is generated by the platform and should be in format alreayd

	timestamp=$( to-timestamp )
	message=$( echo "$INPUT" | jq -aR . )
	printf '{ "@timestamp": "%s", "origin": "%s", "source": "logger", "level": "%s", "message":%s }\n' "$timestamp" "$CONTECO_IMAGE" "$level" "$message"

done

#!/usr/bin/env bash

# the default is to return the message as is
# each container type instance can implement its own if required
#stream=$1
#INPUT=$2

# check if it is httplogs
#if [[ $INPUT == "{"* ]] ; then

#	source=$(echo "$INPUT" | jq -r '. | .source')
#	if [[ $source == "httplogs" ]] ; then
#
#		requestline=$(echo "$INPUT" | jq -r '. | .requestline')
#		request_method=$( echo "$requestline" | cut -d ' ' -f 1)
#		request_url=$( echo "$requestline" | cut -d ' ' -f 2)
#		request_protocol=$( echo "$requestline" | cut -d ' ' -f 3)
#
#		INPUT=$(echo $INPUT | jq --arg method $request_method '. + {method: $method}' | jq --arg url $request_url '. + {url: $url}' | jq --arg protocol $request_protocol '. + {protocol: $protocol}' | jq 'del(.requestline)')
#
#		printf "%s" "$INPUT"
#		exit
#
#	fi

#fi

#level=$(echo $INPUT | cut -d '[' -f2 | cut -d ']' -f1)
#if [[ $level == "warn" ]] ; then
#	LEVEL="WARNING"
#	MESSAGE=$(echo $INPUT | cut -d ']' -f2 | jq -aR .)
#elif [[ $level == "error" ]] ; then
#	LEVEL="ERROR"
#	MESSAGE=$(echo $INPUT | cut -d ']' -f2 | jq -aR .)
#else
#	LEVEL="INFO"
#	MESSAGE=$(echo $INPUT | cut -d ']' -f2 | jq -aR .)
#fi
#printf '{ "source": "logger", "level": "%s", "message":%s }' "$LEVEL" "$MESSAGE"
